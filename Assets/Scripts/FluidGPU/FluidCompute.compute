#pragma kernel Init
#pragma kernel UpdateObstacleMap
#pragma kernel UpdateObstacleEdges
#pragma kernel Interaction
#pragma kernel PressureSolvePrepare
#pragma kernel PressureSolve
#pragma kernel VelocityPressureUpdate
#pragma kernel VelocitySelfAdvection
#pragma kernel AdvectedVelocityReadback

struct SceneElement {
    int shapeType;
    int isObstacle;
    float2 pos;
    float2 posLineEnd;
    float2 size;
    float2 velocitySource;
};

// --- Constants --- //
static const uint LEFT = 0;
static const uint RIGHT = 1;
static const uint BOTTOM = 2;
static const uint TOP = 3;

// --- Settings --- //
const uint2 resolution;
const float time;
const float deltaTime;
const uint2 cellSize;
const bool openRightEdge;
const bool openTopEdge;

// --- Buffers --- //
StructuredBuffer<SceneElement> elements;
const int elementCount;

// --- Maps --- //
RWTexture2D<float2> VelocityMap;
RWTexture2D<float2> VelocityMapAdvected;
RWTexture2D<float2> ObstacleMap; // x > 0 = obstacle, y is precomputed map of neighbour edges
RWTexture2D<float> PressureMap;
RWTexture2D<float2> PressureSolveData;

// --- Samplers --- //
Texture2D<float2> VelocityMapSample;
SamplerState samplerVelocityMapSample;

// --- Interaction --- //
const bool interaction_AddSmoke;
const bool interaction_SetVelocities;
const float interaction_Radius;
const float brushStrength;
const float2 interaction_Center;
const float2 interaction_Delta;

// --- Solver --- //
const bool clearPressure;
const uint halfCellCount;
const uint passIndex;
const float weightSOR = 1.7;
const float K; // timestep / (density * cellSize)

// --- Utilities --- //
float2 CellCenterFromCoord(int x, int y) {
    return (float2(x + 0.5, y + 0.5) - resolution * 0.5) * cellSize;
}

float2 CellEdgeLeft(int x, int y) {
    return (float2(x, y + 0.5) - resolution * 0.5) * cellSize;
}

float2 CellEdgeBottom(int x, int y) {
    return (float2(x + 0.5, y) - resolution * 0.5) * cellSize;
}

uint2 ClampCoord(int x, int y, int w, int h) {
    return uint2(max(0, min(x, w - 1)), max(0, min(y, h - 1)));
}

uint2 ClampCoord(int x, int y) {
    return ClampCoord(x, y, resolution.x, resolution.y);
}

bool IsSolidCell(int x, int y) {
    return ObstacleMap[ClampCoord(x, y)].r > 0.f;
}

bool BoxContainsPoint(float2 boxCenter, float2 boxSize, float2 p) {
    float2 o = abs(p - boxCenter) * 2;
    return (o.x <= boxSize.x && o.y <= boxSize.y);
}

bool CircleContainsPoint(float2 center, float radius, float2 p) {
    float2 offset = center - p;
    float sqrDst = dot(offset, offset);
    return sqrDst < radius * radius;
}

// Get point on the line segment (a1, a2) that's closest to the given point (p)
float3 ClosestPointOnLineSegment(float3 p, float3 a1, float3 a2) {
    float3 lineDelta = a2 - a1;
    float3 pointDelta = p - a1;
    float sqrLineLength = dot(lineDelta, lineDelta);
    if (sqrLineLength == 0)
        return a1;

    float t = saturate(dot(pointDelta, lineDelta) / sqrLineLength);
    return a1 + lineDelta * t;
}

// Calculates smallest distance from given point to the line segment (a1, a2)
float DistanceToLineSegment(float3 p, float3 a1, float3 a2) {
    float3 closestPoint = ClosestPointOnLineSegment(p, a1, a2);
    return length(p - closestPoint);
}

bool IsPointInSceneElement(SceneElement element, float2 pos) {
    if (element.shapeType == 0) // Circle
        return CircleContainsPoint(element.pos, element.size.x, pos);
    else if (element.shapeType == 1) // Quad
        return BoxContainsPoint(element.pos, element.size, pos);
    else // Line
        return DistanceToLineSegment(float3(pos, 0), float3(element.pos, 0), float3(element.posLineEnd, 0)) < element.size.x;
}

float GetPressure(int x, int y) {
    if (x < 0 || x >= (int)resolution.x || y < 0 || y >= (int)resolution.y) return 0;
    return PressureMap[int2(x, y)];
}

uint2 CheckerboardCoord(uint i, uint passIndex, uint2 resolution) {
    uint coordY = i / (resolution.x / 2); // Note: width assumed to be even
    uint coordX = (2 * i) % resolution.x;
    if (coordY % 2 != passIndex % 2)
        coordX++;
    return uint2(coordX, coordY);
}

float2 GetVelocityAtWorldPos(float2 worldPos) {
    int2 numCells = (int2)resolution;

    // Velocity x
    float2 bottomLeftX = float2(-numCells.x / 2.0 - 0.5, -numCells.y / 2.0) * cellSize;
    float2 topRightX = float2(numCells.x / 2.0 - 0.5, numCells.y / 2.0) * cellSize;
    float2 uvX = (worldPos - bottomLeftX) / (topRightX - bottomLeftX);
    float velocityX = VelocityMapSample.SampleLevel(samplerVelocityMapSample, uvX, 0).r;

    // Velocity y
    float2 bottomLeftY = float2(-numCells.x / 2.0, -numCells.y / 2.0 - 0.5) * cellSize;
    float2 topRightY = float2(numCells.x / 2.0, numCells.y / 2.0 - 0.5) * cellSize;
    float2 uvY = (worldPos - bottomLeftY) / (topRightY - bottomLeftY);
    float velocityY = VelocityMapSample.SampleLevel(samplerVelocityMapSample, uvY, 0).y;

    return float2(velocityX, velocityY);
}

float2 RewindPos(float2 worldPos) {
    float2 velocity = GetVelocityAtWorldPos(worldPos);
    float2 posOld = worldPos - velocity * deltaTime;
    return posOld;
}

// --- Kernels --- //
[numthreads(8,8,1)]
void Init(uint3 id : SV_DispatchThreadID) {
    if (id.x >= resolution.x || id.y >= resolution.y) return;

    ObstacleMap[id.xy] = 0;
    VelocityMap[id.xy] = 0;
    PressureMap[id.xy] = 0;
}

[numthreads(8,8,1)]
void UpdateObstacleMap(uint3 id : SV_DispatchThreadID) {
    if (id.x >= resolution.x || id.y >= resolution.y) return;

    bool isObstacle = ObstacleMap[id.xy].x > 0;

    // Map border
    bool isMapBoundary = id.x == 0 || id.y == 0;
    if (!openRightEdge) isMapBoundary = isMapBoundary | (id.x == resolution.x - 1);
    if (!openTopEdge) isMapBoundary = isMapBoundary | id.y == resolution.y - 1;
    if (isMapBoundary) isObstacle = true;

    float2 worldPos = CellCenterFromCoord(id.x, id.y);
    if (!isObstacle) {
        for (int i = 0; i < elementCount; i++) {
            SceneElement element = elements[i];
            if (element.isObstacle && IsPointInSceneElement(element, worldPos)) {
                isObstacle = true;
                break;
            }
        }
    }

    ObstacleMap[id.xy] = float2(isObstacle, 0);
}

[numthreads(8,8,1)]
void UpdateObstacleEdges(uint3 id : SV_DispatchThreadID) {
    if (id.x >= resolution.x || id.y >= resolution.y) return;

    int obstacleSelf = IsSolidCell(id.x, id.y);
    int obstacleEdgeT = obstacleSelf | IsSolidCell(id.x, id.y + 1);
    int obstacleEdgeB = obstacleSelf | IsSolidCell(id.x, id.y - 1);
    int obstacleEdgeL = obstacleSelf | IsSolidCell(id.x - 1, id.y);
    int obstacleEdgeR = obstacleSelf | IsSolidCell(id.x + 1, id.y);

    int edgeCase = (obstacleEdgeL << LEFT) | (obstacleEdgeR << RIGHT) | (obstacleEdgeB << BOTTOM) | (obstacleEdgeT << TOP);
    ObstacleMap[id.xy] = float2(obstacleSelf, edgeCase);
}

[numthreads(8,8,1)]
void Interaction(uint3 id : SV_DispatchThreadID) {
    if (id.x >= resolution.x || id.y >= resolution.y) return;

    float2 cellCenterWorld = CellCenterFromCoord(id.x, id.y);
    float2 offset = interaction_Center - cellCenterWorld;
    float sqrRadius = interaction_Radius * interaction_Radius;
    float interactionSqrDst = dot(offset, offset);

    if (interaction_AddSmoke && interactionSqrDst < sqrRadius) {
        float brushWeight = 1 - smoothstep(0.1, 0.9, interactionSqrDst / sqrRadius);
        float smokeAdd = deltaTime * deltaTime / unscaledDeltaTime * 150 * brushWeight;
        SmokeMap[id.xy] = SmokeMap[id.xy] + float4(0, smokeAdd, 0, 0);
    }

    if (interaction_SetVelocities) {
        float wL = MouseInteractionWeight(CellEdgeLeft(id.x, id.y));
        float wB = MouseInteractionWeight(CellEdgeBottom(id.x, id.y));
        float2 velocityAdd = interaction_Delta * velocityMultiplier;

        int obstacleSelf = IsSolidCell(id.x, id.y);
        int obstacleEdge_W = obstacleSelf | IsSolidCell(id.x - 1, id.y);
        int obstacleEdge_S = obstacleSelf | IsSolidCell(id.x, id.y - 1);

        float2 packedVelAdd = velocityAdd.xy * float2(wL, wB);
        packedVelAdd.x *= (1 - obstacleEdge_W);
        packedVelAdd.y *= (1 - obstacleEdge_S);
        VelocityMap[id.xy] += packedVelAdd;
    }
}

[numthreads(8,8,1)]
void PressureSolvePrepare(uint3 id : SV_DispatchThreadID) {
    if (id.x >= resolution.x || id.y >= resolution.y) return;

    // Figure out which edges fluid can flow across
    int isSolidCell = IsSolidCell(id.x, id.y);
    int flowTop = 1 - (isSolidCell | IsSolidCell(id.x, id.y + 1));
    int flowLeft = 1 - (isSolidCell | IsSolidCell(id.x - 1, id.y));
    int flowRight = 1 - (isSolidCell | IsSolidCell(id.x + 1, id.y));
    int flowBottom = 1 - (isSolidCell | IsSolidCell(id.x, id.y - 1));
    // Pack edges permitting flow into 4bit integer
    int edgeFlow = flowLeft << LEFT | flowRight << RIGHT | flowBottom << BOTTOM | flowTop << TOP;

    // Compute velocity term of pressure calculation
    float velocityTop = VelocityMap[ClampCoord(id.x, id.y + 1)].y;
    float velocityRight = VelocityMap[ClampCoord(id.x + 1, id.y)].x;
    float velocityBottom = VelocityMap[id.xy].y;
    float velocityLeft = VelocityMap[id.xy].x;

    float velocityTerm;
    int edgeFlowCount = flowTop + flowBottom + flowLeft + flowRight;

    if (edgeFlowCount == 0)
        velocityTerm = 0;
    else
        velocityTerm = (velocityRight - velocityLeft + velocityTop - velocityBottom) / (edgeFlowCount * K);

    PressureSolveData[id.xy] = float2(velocityTerm, edgeFlow);
    if (clearPressure)
        PressureMap[id.xy] = 0;
}

[numthreads(64,1,1)]
void PressureSolve(uint3 threadIndex : SV_DispatchThreadID)
{
    if (threadIndex.x >= halfCellCount) return;

    uint2 cell = CheckerboardCoord(threadIndex.x, passIndex, resolution);

    // Unpack precomputed data
    float velocityTerm = PressureSolveData[cell].r;
    int edgeFlow = (int)PressureSolveData[cell].g;
    int flowTop = (edgeFlow >> TOP) & 1;
    int flowLeft = (edgeFlow >> LEFT) & 1;
    int flowRight = (edgeFlow >> RIGHT) & 1;
    int flowBottom = (edgeFlow >> BOTTOM) & 1;
    int edgeFlowCount = flowTop + flowBottom + flowLeft + flowRight;
    if (edgeFlowCount == 0) return;

    // Solve pressure
    float pressureTop = GetPressure(cell.x, cell.y + 1) * flowTop;
    float pressureLeft = GetPressure(cell.x - 1, cell.y) * flowLeft;
    float pressureRight = GetPressure(cell.x + 1, cell.y) * flowRight;
    float pressureBottom = GetPressure(cell.x, cell.y - 1) * flowBottom;
    float pressureTerm = (pressureLeft + pressureRight + pressureBottom + pressureTop) / edgeFlowCount;
    float pressureNew = pressureTerm - velocityTerm;

    // Successive over-relaxation
    float pressureOld = PressureMap[cell];
    PressureMap[cell] = pressureOld + (pressureNew - pressureOld) * weightSOR;
}

void VelocityPressureUpdate(uint3 id : SV_DispatchThreadID) {
    if (id.x >= resolution.x || id.y >= resolution.y) return;

    int obstacleEdgeCase = (int)ObstacleMap[id.xy].g;
    int canFlowL = 1 - ((obstacleEdgeCase >> LEFT) & 1);
    int canFlowR = 1 - ((obstacleEdgeCase >> RIGHT) & 1);
    int canFlowD = 1 - ((obstacleEdgeCase >> BOTTOM) & 1);
    int canFlowU = 1 - ((obstacleEdgeCase >> TOP) & 1);

    int flowableEdgeCount = canFlowU + canFlowD + canFlowL + canFlowR;
    if (flowableEdgeCount == 0) return;

    float pressureLeft = PressureMap[int2(id.x - 1, id.y)].r;
    float pressureDown = PressureMap[int2(id.x, id.y - 1)].r;
    float pressureCenter = PressureMap[int2(id.x, id.y)].r;

    float2 edgeVelocityComponents = VelocityMap[id.xy];
    float velocityLeft = edgeVelocityComponents.x;
    float velocityBottom = edgeVelocityComponents.y;

    if (canFlowL)
        velocityLeft = (velocityLeft - K * (pressureCenter - pressureLeft));
    if (canFlowD)
        velocityBottom = (velocityBottom - K * (pressureCenter - pressureDown));

    VelocityMap[id.xy] = float2(velocityLeft, velocityBottom);
}

[numthreads(8,8,1)]
void VelocitySelfAdvection(uint3 id : SV_DispatchThreadID) {
    if (id.x >= resolution.x || id.y >= resolution.y) return;

    int obstacleEdgeCase = (int)ObstacleMap[id.xy].g;
    int obstacleLeft = (obstacleEdgeCase >> LEFT) & 1;
    int obstacleBottom = (obstacleEdgeCase >> BOTTOM) & 1;

    float2 velAdvected = 0;
    if (!obstacleLeft) {
        float2 pos = CellEdgeLeft(id.x, id.y);
        float2 posOld = RewindPos(pos);
        velAdvected.x = GetVelocityAtWorldPos(posOld).x;
    }
    else
        velAdvected.x = VelocityMapSample[id.xy].x;

    if (!obstacleBottom) {
        float2 pos = CellEdgeBottom(id.x, id.y);
        float2 posOld = RewindPos(pos);
        velAdvected.y = GetVelocityAtWorldPos(posOld).y;
    }
    else
        velAdvected.y = VelocityMapSample[id.xy].y;

    VelocityMapAdvected[id.xy] = velAdvected;
}

[numthreads(8,8,1)]
void AdvectedVelocityReadback(uint3 id : SV_DispatchThreadID) {
    if (id.x >= resolution.x || id.y >= resolution.y) return;
    VelocityMap[id.xy] = VelocityMapAdvected[id.xy];
}
